#pragma once
#include "input.hpp"
#include <cmath>
#include <cstdint>
#include <iostream>
#include <limits>
#include <tuple>
#include <vector>

/**
  Bob sends and Alice receives. Keys must be first generated by Alice.
*/

namespace elgamal {
class Alice {
public:
  std::uint32_t _prime;
  std::uint16_t _generator;

  Alice();

  const std::string decrypt_message(const std::vector<std::uint32_t> &cipher);

private:
  std::uint32_t _private;
  std::uint32_t _shared_secret;
};
class Bob {
public:
  std::uint32_t _prime;
  std::uint32_t c1;
  std::vector<std::uint32_t> c2;

  Bob();

  // Encrypts the message, and returns two cipher to be published.
  std::tuple<std::uint32_t, std::vector<std::uint32_t>>
  encrypt_message(const std::vector<std::uint32_t> &message);

private:
  std::uint32_t _ephemeral_key;
  std::uint32_t _shared_secret;
};

} // namespace elgamal

struct Elgamal {
  // Large prime number.
  std::uint32_t _prime{0};
  // Generator of multiplicative group Zp*..
  std::uint16_t _generator{0};

  std::uint32_t _ciphertext1{0};

  std::vector<std::uint32_t> _ciphertext2{0};

  std::uint32_t _alice_private{0};

  std::uint32_t _public_key{0};

  std::uint32_t _ephemeral_key{0};

  std::uint32_t _shared_secret{0};

  Elgamal() = delete;

  /**
    @brief Generates the keys, which are mainly Alice's. Ephemeral key not
    generated yet.
  */
  Elgamal(std::uint8_t bit);

  /**
    @brief Encrypts the message, stores it, and updates Bob's keys properly.
  */
  void encrypt_message(std::vector<std::uint32_t> message);

  /**
    @brief Decrypts the message, which is the stored ciphertext2.
  */
  void decrypt_message();
};

/**
    @brief Receiver can decrypt the message using the shared secret.
  */
std::string decrypt_message(std::vector<std::uint32_t> cipher,
                            std::uint32_t shared_secret, std::uint32_t prime);

/**
  Simple representation of the Elgamal encryption for the user.
*/
void elgamal_demo();

namespace elgamal {
class Bob;
class Alice;
} // namespace elgamal
